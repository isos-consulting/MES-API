import express = require('express');
import ApiResult from '../../interfaces/common/api-result.interface';
import IInvStore from '../../interfaces/inv/store.interface';
import sequelize from '../../models';
import InvStoreRepo from '../../repositories/inv/store.repository';
import PrdOrderInputRepo from '../../repositories/prd/order-input.repository';
import PrdOrderRoutingRepo from '../../repositories/prd/order-routing.repository';
import PrdOrderWorkerRepo from '../../repositories/prd/order-worker.repository';
import PrdOrderRepo from '../../repositories/prd/order.repository';
import PrdWorkDowntimeRepo from '../../repositories/prd/work-downtime.repository';
import PrdWorkInputRepo from '../../repositories/prd/work-input.repository';
import PrdWorkRejectRepo from '../../repositories/prd/work-reject.repository';
import PrdWorkRoutingRepo from '../../repositories/prd/work-routing.repository';
import PrdWorkWorkerRepo from '../../repositories/prd/work-worker.repository';
import PrdWorkRepo from '../../repositories/prd/work.repository';
import QmsInspResultDetailInfoRepo from '../../repositories/qms/insp-result-detail-info.repository';
import QmsInspResultDetailValueRepo from '../../repositories/qms/insp-result-detail-value.repository';
import QmsInspResultRepo from '../../repositories/qms/insp-result.repository';
import StdEquipRepo from '../../repositories/std/equip.repository';
import StdFactoryRepo from '../../repositories/std/factory.repository';
import StdLocationRepo from '../../repositories/std/location.repository';
import StdProcRepo from '../../repositories/std/proc.repository';
import StdProdRepo from '../../repositories/std/prod.repository';
import StdShiftRepo from '../../repositories/std/shift.repository';
import StdStoreRepo from '../../repositories/std/store.repository';
import StdWorkingsRepo from '../../repositories/std/workings.repository';
import checkArray from '../../utils/checkArray';
import convertToReportRaws from '../../utils/convertToReportRaws';
import getStoreBody from '../../utils/getStoreBody';
import getSubtractTwoDates from '../../utils/getSubtractTwoDates';
import getTranTypeCd from '../../utils/getTranTypeCd';
import response from '../../utils/response';
import testErrorHandlingHelper from '../../utils/testErrorHandlingHelper';
import unsealArray from '../../utils/unsealArray';
import BaseCtl from '../base.controller';

class PrdWorkCtl extends BaseCtl {
  // ‚úÖ Inherited Functions Variable
  // result: ApiResult<any>;

  // ‚úÖ Î∂ÄÎ™® Controller (BaseController) Ïùò repository Î≥ÄÏàòÍ∞Ä any Î°ú ÏÉùÏÑ± ÎêòÏñ¥ÏûàÍ∏∞ ÎïåÎ¨∏Ïóê ÏûêÏãù Controller(this) ÏóêÏÑú Type ÏßÄÏ†ï
  repo: PrdWorkRepo;
  inputRepo: PrdWorkInputRepo;
  workerRepo: PrdWorkWorkerRepo;
  rejectRepo: PrdWorkRejectRepo;
  downtimeRepo: PrdWorkDowntimeRepo;
  routingRepo: PrdWorkRoutingRepo;
  orderRepo: PrdOrderRepo;
  orderInputRepo: PrdOrderInputRepo;
  orderWorkerRepo: PrdOrderWorkerRepo;
  orderRoutingRepo: PrdOrderRoutingRepo;
  storeRepo: InvStoreRepo;
  inspResultRepo: QmsInspResultRepo;
  inspResultDetailInfoRepo: QmsInspResultDetailInfoRepo;
  inspResultDetailValueRepo: QmsInspResultDetailValueRepo;

  //#region ‚úÖ Constructor
  constructor() {
    // ‚úÖ Î∂ÄÎ™® Controller (Base Controller) Ïùò CRUD Function Í≥º ÏÉÅÏÜç Î∞õÎäî ÏûêÏãù Controller(this) Ïùò Repository Î•º Ïó∞Í≤∞ÌïòÍ∏∞ ÏúÑÌïòÏó¨ ÏÉùÏÑ±ÏûêÏóêÏÑú Repository ÏÉùÏÑ±
    super(new PrdWorkRepo());
    this.inputRepo = new PrdWorkInputRepo();
    this.workerRepo = new PrdWorkWorkerRepo();
    this.rejectRepo = new PrdWorkRejectRepo();
    this.downtimeRepo = new PrdWorkDowntimeRepo();
    this.routingRepo = new PrdWorkRoutingRepo();
    this.orderRepo = new PrdOrderRepo();
    this.orderInputRepo = new PrdOrderInputRepo();
    this.orderWorkerRepo = new PrdOrderWorkerRepo();
    this.orderRoutingRepo = new PrdOrderRoutingRepo();
    this.storeRepo = new InvStoreRepo();
    this.inspResultRepo = new QmsInspResultRepo();
    this.inspResultDetailInfoRepo = new QmsInspResultDetailInfoRepo();
    this.inspResultDetailValueRepo = new QmsInspResultDetailValueRepo();

    // ‚úÖ CUD Ïó∞ÏÇ∞Ïù¥ Ïã§ÌñâÎêòÍ∏∞ Ï†Ñ Fk Table Ïùò uuid Î°ú id Î•º Í≤ÄÏÉâÌïòÏó¨ request body Ïóê ÏÇΩÏûÖÌïòÍ∏∞ ÏúÑÌïòÏó¨ Ï†ïÎ≥¥ Setting
    this.fkIdInfos = [
      {
        key: 'uuid',
        repo: new PrdWorkRepo(),
        idName: 'work_id',
        uuidName: 'uuid'
      },
      {
        key: 'factory',
        repo: new StdFactoryRepo(),
        idName: 'factory_id',
        uuidName: 'factory_uuid'
      },
      {
        key: 'order',
        repo: new PrdOrderRepo(),
        idName: 'order_id',
        uuidName: 'order_uuid'
      },
      {
        key: 'proc',
        repo: new StdProcRepo(),
        idName: 'proc_id',
        uuidName: 'proc_uuid'
      },
      {
        key: 'workings',
        repo: new StdWorkingsRepo(),
        idName: 'workings_id',
        uuidName: 'workings_uuid'
      },
      {
        key: 'equip',
        repo: new StdEquipRepo(),
        idName: 'equip_id',
        uuidName: 'equip_uuid'
      },
      {
        key: 'prod',
        repo: new StdProdRepo(),
        idName: 'prod_id',
        uuidName: 'prod_uuid'
      },
      {
        key: 'shift',
        repo: new StdShiftRepo(),
        idName: 'shift_id',
        uuidName: 'shift_uuid'
      },
      {
        key: 'store',
        repo: new StdStoreRepo(),
        idAlias: 'to_store_id',
        idName: 'store_id',
        uuidName: 'to_store_uuid'
      },
      {
        key: 'location',
        repo: new StdLocationRepo(),
        idAlias: 'to_location_id',
        idName: 'location_id',
        uuidName: 'to_location_uuid'
      }
    ];
  };
  //#endregion

  //#region ‚úÖ CRUD Functions

  //#region üü¢ Create Functions

  // üìí Fn[create] (‚úÖ Inheritance): Default Create Function
  public create = async (req: express.Request, res: express.Response, next: express.NextFunction) => {
    try {
      req.body = await this.getFkId(req.body, this.fkIdInfos);
      this.result = { raws: [], count: 0 };

      // ‚ùó ÏûëÏóÖÏßÄÏãúÍ∞Ä ÎßàÍ∞êÎêòÏñ¥ ÏûàÎäî Í≤ΩÏö∞ Interlock
      const orderUuids = req.body.map((data: any) => { return data.order_uuid; });
      const orderRead = await this.orderRepo.readRawsByUuids(orderUuids);
      orderRead.raws.forEach((order: any) => {
        if (order.complete_fg) { throw new Error(`ÏßÄÏãúÎ≤àÌò∏ [${order.order_uuid}]Í∞Ä Ïù¥ÎØ∏ ÏôÑÎ£åÏÉÅÌÉúÏûÖÎãàÎã§.`); }
      });

      await sequelize.transaction(async(tran) => { 
        for await (const data of req.body) {
          // üìå ÏûëÏóÖÏßÄÏãú Îã®ÏúÑ ÏµúÎåÄ ÏàúÎ≤à Ï°∞Ìöå
          const maxSeq = await this.repo.getMaxSeq(data.order_id, tran);
          data.seq = maxSeq + 1;

          // üìå ÏÉùÏÇ∞Ïã§Ï†Å Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
          const workResult = await this.repo.create(checkArray(data), req.user?.uid as number, tran);
          this.result.count += workResult.count;
          const work = unsealArray(workResult.raws);

          // üìå ÏûëÏóÖÏßÄÏãú ÌÖåÏù¥Î∏î work_fg(ÏÉùÏÇ∞ÏßÑÌñâÏó¨Î∂Ä) TrueÎ°ú Î≥ÄÍ≤Ω
          const orderResult = await this.orderRepo.updateWorkFgById(work.order_id, true, req.user?.uid as number, tran);

          // üìå ÏûëÏóÖÏßÄÏãúÏùò ÏûëÏóÖÏûê Ìà¨ÏûÖÏ†ïÎ≥¥ Í∏∞Ï§Ä Ï¥àÍ∏∞ Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
          const orderWorkerRead = await this.orderWorkerRepo.readRawsByOrderId(work.order_id, tran);
          const workerBody = orderWorkerRead.raws.map((orderWorker: any) => {
            return {
              factory_id: orderWorker.factory_id,
              work_id: work.work_id,
              worker_id: orderWorker.worker_id
            };
          });
          const workerResult = await this.workerRepo.create(workerBody, req.user?.uid as number, tran);
          this.result.count += workerResult.count;

          // üìå ÏûëÏóÖÏßÄÏãúÏùò Í≥µÏ†ïÏàúÏÑú Ï†ïÎ≥¥ Í∏∞Ï§Ä Ï¥àÍ∏∞ Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
          const orderRoutingRead = await this.orderRoutingRepo.readRawsByOrderId(work.order_id, tran);
          const routingBody = orderRoutingRead.raws.map((orderRouting: any) => {
            return {
              factory_id: orderRouting.factory_id,
              work_id: work.work_id,
              proc_id: orderRouting.proc_id,
              proc_no: orderRouting.proc_no,
              workings_id: orderRouting.workings_id,
              equip_id: orderRouting.equip_id
            };
          });
          const routingResult = await this.routingRepo.create(routingBody, req.user?.uid as number, tran);
          this.result.count += routingResult.count;

          this.result.raws.push({
            work: work,
            order: orderResult.raws,
            worker: workerResult.raws,
            routing: routingResult.raws
          });
        }
      });

      return response(res, this.result.raws, { count: this.result.count }, '', 201);
    } catch (e) {
      return process.env.NODE_ENV === 'test' ? testErrorHandlingHelper(e, res) : next(e);
    }
  };

  //#endregion

  //#region üîµ Read Functions

  // üìí Fn[read] (‚úÖ Inheritance): Default Read Function
  // public read = async (req: express.Request, res: express.Response, next: express.NextFunction) => {
  // }

  // üìí Fn[readReport]: Ïã§Ï†ÅÌòÑÌô© Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå
  public readReport = async (req: express.Request, res: express.Response, next: express.NextFunction) => {
    try {
      const params = Object.assign(req.query, req.params);
      const subTotalType = params.sub_total_type as string;

      if (![ 'proc', 'prod', 'date', 'none' ].includes(subTotalType)) { throw new Error('ÏûòÎ™ªÎêú sub_total_type(ÏÜåÍ≥Ñ Ïú†Ìòï) ÏûÖÎ†•') }

      this.result = await this.repo.readReport(params);
      this.result.raws = convertToReportRaws(this.result.raws);
      
      return response(res, this.result.raws, { count: this.result.count });
    } catch (e) {
      return process.env.NODE_ENV === 'test' ? testErrorHandlingHelper(e, res) : next(e);
    }
  };

  //#endregion

  //#region üü° Update Functions

  // üìí Fn[update] (‚úÖ Inheritance): Default Update Function
  // public update = async (req: express.Request, res: express.Response, next: express.NextFunction) => {
  // }

  // üìí Fn[updateComplete]: ÏÉùÏÇ∞Ïã§Ï†Å ÏôÑÎ£åÏ≤òÎ¶¨
  public updateComplete = async (req: express.Request, res: express.Response, next: express.NextFunction) => {
    try {
      req.body = checkArray(req.body);
      this.result = { raws: [], count: 0 };

      await sequelize.transaction(async(tran) => { 
        for await (const data of req.body) {
          const workRead = await this.repo.readRawByUuid(data.uuid);
          const work = unsealArray(workRead.raws);

          // ‚ùó ÏÉùÏÇ∞ ÏàòÎüâÍ≥º Ìà¨ÏûÖ ÏàòÎüâÏù¥ ÏùºÏπòÌïòÏßÄ ÏïäÏùÑ Í≤ΩÏö∞ Interlock
          let verifyInput: any = {};
          const orderInputRead = await this.orderInputRepo.readRawsByOrderId(work.order_id, tran);
          orderInputRead.raws.forEach((orderInput: any) => {
            verifyInput[orderInput.prod_id] = { usage: orderInput.c_usage, qty: 0 }
          });

          const inputRead = await this.inputRepo.readRawsByWorkId(work.work_id, tran);
          inputRead.raws.forEach((input: any) => {
            if (!verifyInput[input.prod_id]) { throw new Error(`ÏûëÏóÖÏßÄÏãúÎåÄÎπÑ Ìà¨ÏûÖÌíàÎ™©Ïù¥ ÏùºÏπòÌïòÏßÄ ÏïäÏäµÎãàÎã§.`); }

            verifyInput[input.prod_id].usage = input.c_usage;
            verifyInput[input.prod_id].qty = Number(input.qty);
          });

          const totalProducedQty = Number(work.qty) + Number(work.reject_qty);
          Object.keys(verifyInput).forEach((prodId: string) => {
            const totalConsumedQty = verifyInput[prodId].usage * verifyInput[prodId].qty;
            if (totalProducedQty != totalConsumedQty) { throw new Error(`Ìà¨ÏûÖÌíàÎ™©Ïùò Ìà¨ÏûÖÏàòÎüâÏù¥ ÏùºÏπòÌïòÏßÄ ÏïäÏäµÎãàÎã§.`); }
          });

          // üìå ÏÉùÏÇ∞Ïã§Ï†Å ÏôÑÎ£å Ï≤òÎ¶¨
          // üìå ÏôÑÎ£åÏùºÏãúÎ•º ÏûÖÎ†•ÌïòÏßÄ ÏïäÏïòÏùÑ Í≤ΩÏö∞ ÌòÑÏû¨ÏùºÏãúÎ°ú ÏûÖÎ†•
          if (!data.end_date) { data.end_date = new Date(); }
          const workTime = getSubtractTwoDates(data.start_date, data.end_date);
          if (workTime <= 0) { throw new Error('ÏûòÎ™ªÎêú ÏãúÏûëÏãúÍ∞Ñ(start_date) Î∞è Ï¢ÖÎ£åÏãúÍ∞Ñ(end_date)Ïù¥ ÏûÖÎ†•ÎêòÏóàÏäµÎãàÎã§.'); }
          const workResult = await this.repo.updateComplete([{ uuid: data.uuid, work_time: workTime, complete_fg: true, end_date: data.end_date }], req.user?.uid as number, tran);

          // üìå Ìï¥Îãπ Ïã§Ï†ÅÏùò ÏûëÏóÖÏßÄÏãúÏóê ÏßÑÌñâÏ§ëÏù∏ ÏÉùÏÇ∞ Ïã§Ï†ÅÏù¥ ÏóÜÏùÑ Í≤ΩÏö∞ ÏûëÏóÖÏßÄÏãúÏùò ÏÉùÏÇ∞ÏßÑÌñâÏó¨Î∂Ä(work_fg)Î•º FalseÎ°ú Î≥ÄÍ≤Ω
          const incompleteWorkCount = await this.repo.getIncompleteCount(work.order_id, tran);
          let orderResult: ApiResult<any> = { raws: [], count: 0 };
          if (incompleteWorkCount == 0) { orderResult = await this.orderRepo.updateWorkFgById(work.order_id, false, req.user?.uid as number, tran); }

          // üìå ÏûÖÍ≥† Ï∞ΩÍ≥† ÏàòÎ∂à ÎÇ¥Ïó≠ ÏÉùÏÑ±
          const toStoreBody: IInvStore[] = getStoreBody(workResult.raws, 'TO', 'work_id', getTranTypeCd('PRD_OUTPUT'), work.reg_date);

          // üìå Î∂ÄÏ†ÅÌï© ÏàòÎüâÏóê ÏùòÌïú Ï∞ΩÍ≥† ÏàòÎ∂à ÎÇ¥Ïó≠ ÏÉùÏÑ±
          const rejectRead = await this.rejectRepo.readRawsByWorkId(work.work_id, tran);
          const rejectStoreBody: IInvStore[] = getStoreBody(rejectRead.raws, 'TO', 'work_reject_id', getTranTypeCd('PRD_REJECT'), work.reg_date);

          // üìå Ï∞ΩÍ≥† ÏàòÎ∂à
          const storeBody = [...toStoreBody, ...rejectStoreBody];
          const storeResult = await this.storeRepo.create(storeBody, req.user?.uid as number, tran);

          this.result.raws.push({
            work: workResult.raws,
            order: orderResult.raws,
            store: storeResult.raws,
          });
        }
      });

      return response(res, this.result.raws, { count: this.result.count }, '', 201);
    } catch (e) {
      return process.env.NODE_ENV === 'test' ? testErrorHandlingHelper(e, res) : next(e);
    }
  }

  // üìí Fn[updateCancelComplete]: ÏôÑÎ£åÎêú ÏÉùÏÇ∞Ïã§Ï†Å Ï∑®ÏÜåÏ≤òÎ¶¨
  public updateCancelComplete = async (req: express.Request, res: express.Response, next: express.NextFunction) => {
    try {
      req.body = checkArray(req.body);
      this.result = { raws: [], count: 0 };

      await sequelize.transaction(async(tran) => { 
        for await (const data of req.body) {
          const workRead = await this.repo.readRawByUuid(data.uuid);
          const work = unsealArray(workRead.raws);

          // ‚ùó ÏûëÏóÖÏßÄÏãúÍ∞Ä ÎßàÍ∞êÎêòÏñ¥ ÏûàÎäî Í≤ΩÏö∞ Interlock
          const orderRead = await this.orderRepo.readRawByPk(work.order_id);
          const order = unsealArray(orderRead.raws);
          if (order.complete_fg) { throw new Error(`ÏßÄÏãúÎ≤àÌò∏ [${order.uuid}]Í∞Ä ÏôÑÎ£åÎêòÏñ¥ Îç∞Ïù¥ÌÑ∞Î•º ÏàòÏ†ïÌï† Ïàò ÏóÜÏäµÎãàÎã§.`); }

          // üìå ÏÉùÏÇ∞Ïã§Ï†Å ÏôÑÎ£å Ï∑®ÏÜå Ï≤òÎ¶¨
          const workResult = await this.repo.updateComplete([{ uuid: work.uuid, work_time: null, complete_fg: false, end_date: null }], req.user?.uid as number, tran);

          // üìå Ìï¥Îãπ Ïã§Ï†ÅÏùò ÏûëÏóÖÏßÄÏãúÏùò ÏÉùÏÇ∞ÏßÑÌñâÏó¨Î∂Ä(work_fg)Î•º TrueÎ°ú Î≥ÄÍ≤Ω
          const orderResult = await this.orderRepo.updateWorkFgById(work.order_id, true, req.user?.uid as number, tran);

          // üìå Ï∞ΩÍ≥† ÏàòÎ∂àÏù¥Î†• ÏÇ≠Ï†ú
          const storeBody = [{ tran_id: work.work_id, inout_fg: true, tran_cd: getTranTypeCd('PRD_OUTPUT') }];
          for await (const work of workResult.raws) {
            const workRejects = await this.rejectRepo.readRawsByWorkId(work.work_id);
            workRejects.raws.forEach((workReject: any) => { storeBody.push({ tran_id: workReject.work_reject_id, inout_fg: true, tran_cd: getTranTypeCd('PRD_REJECT') }); });
          }
          const storeResult = await this.storeRepo.deleteToTransaction(storeBody, req.user?.uid as number, tran);

          this.result.raws.push({
            work: workResult.raws,
            order: orderResult.raws,
            store: storeResult.raws,
          });
        }
      });

      return response(res, this.result.raws, { count: this.result.count }, '', 201);
    } catch (e) {
      return process.env.NODE_ENV === 'test' ? testErrorHandlingHelper(e, res) : next(e);
    }
  }

  //#endregion

  //#region üü† Patch Functions

  // üìí Fn[patch] (‚úÖ Inheritance): Default Patch Function
  // public patch = async (req: express.Request, res: express.Response, next: express.NextFunction) => {
  // }

  //#endregion

  //#region üî¥ Delete Functions

  // üìí Fn[delete] (‚úÖ Inheritance): Default Delete Function
  public delete = async (req: express.Request, res: express.Response, next: express.NextFunction) => {
    try {
      req.body = checkArray(req.body);
      this.result = { raws: [], count: 0 };

      await sequelize.transaction(async(tran) => { 
        for await (const data of req.body) {
          const workRead = await this.repo.readRawByUuid(data.uuid);
          const work = unsealArray(workRead.raws);

          // ‚ùó ÏûëÏóÖÏßÄÏãúÍ∞Ä ÎßàÍ∞êÎêòÏñ¥ ÏûàÎäî Í≤ΩÏö∞ Interlock
          const orderRead = await this.orderRepo.readRawByPk(work.order_id);
          const order = unsealArray(orderRead.raws);
          if (order.complete_fg) { throw new Error(`ÏßÄÏãúÎ≤àÌò∏ [${order.uuid}]Í∞Ä ÏôÑÎ£åÎêòÏñ¥ Îç∞Ïù¥ÌÑ∞Î•º ÏÇ≠Ï†úÌï† Ïàò ÏóÜÏäµÎãàÎã§.`); }

          // üìå Ï∞ΩÍ≥† ÏàòÎ∂àÏù¥Î†• ÏÇ≠Ï†ú
          const storeBody = [{ tran_id: work.work_id, inout_fg: true, tran_cd: getTranTypeCd('PRD_OUTPUT') }];
          const workRejects = await this.rejectRepo.readRawsByWorkId(work.work_id);
          workRejects.raws.forEach((workReject: any) => { storeBody.push({ tran_id: workReject.work_reject_id, inout_fg: true, tran_cd: getTranTypeCd('PRD_REJECT') }); });
          const workInputs = await this.inputRepo.readRawsByWorkId(work.work_id);
          workInputs.raws.forEach((workInput: any) => { storeBody.push({ tran_id: workInput.work_input_id, inout_fg: false, tran_cd: getTranTypeCd('PRD_INPUT') }); });
          const storeResult = await this.storeRepo.deleteToTransaction(storeBody, req.user?.uid as number, tran);

          // üìå ÏÉùÏÇ∞Ïã§Ï†Å Í¥ÄÎ†® ÌÖåÏù¥Î∏î ÏÇ≠Ï†ú
          const inputResult = await this.inputRepo.deleteByWorkId(work.work_id, req.user?.uid as number, tran);
          const workerResult = await this.workerRepo.deleteByWorkId(work.work_id, req.user?.uid as number, tran);
          const routingResult = await this.routingRepo.deleteByWorkId(work.work_id, req.user?.uid as number, tran);
          const rejectResult = await this.rejectRepo.deleteByWorkId(work.work_id, req.user?.uid as number, tran);
          const downtimeResult = await this.downtimeRepo.deleteByWorkId(work.work_id, req.user?.uid as number, tran);

          // üìå Í≥µÏ†ïÍ≤ÄÏÇ¨ Ïù¥Î†• ÏÇ≠Ï†ú
          let inspHeaderResult: ApiResult<any> = { raws: [], count: 0 };
          let detailInfosResult: ApiResult<any> = { raws: [], count: 0 };
          let detailValuesResult: ApiResult<any> = { raws: [], count: 0 };

          const inspResultRead = await this.inspResultRepo.readProcByWorkId(work.work_id);
          for await (const inspResult of inspResultRead.raws) {
            // üìå Í≤ÄÏÇ¨ ÏÑ±Ï†ÅÏÑú ÏÉÅÏÑ∏ Í∞íÏùÑ ÏÇ≠Ï†úÌïòÍ∏∞ ÏúÑÌïòÏó¨ Í≤ÄÏÇ¨ ÏÑ±Ï†ÅÏÑú ÏÉÅÏÑ∏Ï†ïÎ≥¥ Id Ï°∞Ìöå
            const detailInfos = await this.inspResultDetailInfoRepo.readByResultId(inspResult.insp_result_id);
            const detailInfoIds = detailInfos.raws.map((raw: any) => { return raw.insp_result_detail_info_id });

            // ‚úÖ Í≤ÄÏÇ¨ÏÑ±Ï†ÅÏÑúÏÉÅÏÑ∏Í∞í ÏÇ≠Ï†ú
            const tempDetailValuesResult = await this.inspResultDetailValueRepo.deleteByInfoIds(detailInfoIds, req.user?.uid as number, tran);
            detailValuesResult.raws = [ ...detailValuesResult.raws, ...tempDetailValuesResult.raws ];
            detailValuesResult.count += tempDetailValuesResult.count;

            // ‚úÖ Í≤ÄÏÇ¨ÏÑ±Ï†ÅÏÑúÏÉÅÏÑ∏Ï†ïÎ≥¥ ÏÇ≠Ï†ú
            const tempDetailInfosResult = await this.inspResultDetailInfoRepo.deleteByResultIds([inspResult.insp_result_id], req.user?.uid as number, tran);
            detailInfosResult.raws = [ ...detailInfosResult.raws, ...tempDetailInfosResult.raws ];
            detailInfosResult.count += tempDetailInfosResult.count;

            // ‚úÖ Í≤ÄÏÇ¨ÏÑ±Ï†ÅÏÑú ÏÇ≠Ï†ú
            const tempHeaderResult = await this.repo.delete(data.header, req.user?.uid as number, tran);
            inspHeaderResult.raws = [ ...inspHeaderResult.raws, ...tempHeaderResult.raws ];
            inspHeaderResult.count += tempHeaderResult.count;
          }

          // üìå ÏÉùÏÇ∞Ïã§Ï†Å Ïù¥Î†• ÏÇ≠Ï†ú
          const workResult = await this.repo.delete([{ uuid: work.uuid }], req.user?.uid as number, tran);

          this.result.raws.push({
            work: workResult.raws,
            input: inputResult.raws,
            worker: workerResult.raws,
            routing: routingResult.raws,
            reject: rejectResult.raws,
            downtime: downtimeResult.raws,
            store: storeResult.raws,
            inspResult: inspHeaderResult.raws,
            inspResultDetailInfo: detailInfosResult.raws,
            inspResultDetailValue: detailValuesResult.raws,
          });

          this.result.count += workResult.count + inputResult.count + workerResult.count + routingResult.count + rejectResult.count + downtimeResult.count;
          this.result.count += storeResult.count + inspHeaderResult.count + detailInfosResult.count + detailValuesResult.count;
        }
      });

      return response(res, this.result.raws, { count: this.result.count }, '', 200);
    } catch (e) {
      return process.env.NODE_ENV === 'test' ? testErrorHandlingHelper(e, res) : next(e);
    }
  }

  //#endregion

  //#endregion

  //#region ‚úÖ Inherited Hooks

  //#region üîµ Read Hooks

  // üìí Fn[beforeRead] (‚úÖ Inheritance): Read DB Tasking Ïù¥ Ïã§ÌñâÎêòÍ∏∞ Ï†Ñ Ìò∏Ï∂úÎêòÎäî Function
  // beforeRead = async(req: express.Request) => {}

  // üìí Fn[afterRead] (‚úÖ Inheritance): Read DB Tasking Ïù¥ Ïã§ÌñâÎêú ÌõÑ Ìò∏Ï∂úÎêòÎäî Function
  // afterRead = async(req: express.Request, result: ApiResult<any>) => {}

  //#endregion

  //#region üü° Update Hooks

  // üìí Fn[beforeUpdate] (‚úÖ Inheritance): Update Transaction Ïù¥ Ïã§ÌñâÎêòÍ∏∞ Ï†Ñ Ìò∏Ï∂úÎêòÎäî Function
  beforeUpdate = async(req: express.Request) => {
    // üìå ÏôÑÎ£åÎêòÏñ¥ÏûàÎäî Ïã§Ï†ÅÏù¥ ÏûàÏùÑÍ≤ΩÏö∞ Îç∞Ïù¥ÌÑ∞ ÏàòÏ†ï Î∂àÍ∞Ä
    const uuids = req.body.map((data: any) => { return data.uuid });
    const workRead = await this.repo.readRawsByUuids(uuids);
    workRead.raws.forEach((work: any) => {
      if (work.work_fg) { throw new Error(`Ïã§Ï†ÅÎ≤àÌò∏ [${work.uuid}]Í∞Ä ÏôÑÎ£åÎêòÏñ¥ Îç∞Ïù¥ÌÑ∞Î•º ÏàòÏ†ïÌï† Ïàò ÏóÜÏäµÎãàÎã§.`); }
    });
  }

  // üìí Fn[beforeTranUpdate] (‚úÖ Inheritance): Update Transaction ÎÇ¥Î∂ÄÏóêÏÑú DB Tasking Ïù¥ Ïã§ÌñâÎêòÍ∏∞ Ï†Ñ Ìò∏Ï∂úÎêòÎäî Function
  // beforeTranUpdate = async(req: express.Request, tran: Transaction) => {}

  // üìí Fn[afterTranUpdate] (‚úÖ Inheritance): Update Transaction ÎÇ¥Î∂ÄÏóêÏÑú DB Tasking Ïù¥ Ïã§ÌñâÎêú ÌõÑ Ìò∏Ï∂úÎêòÎäî Function
  // afterTranUpdate = async(req: express.Request, result: ApiResult<any>, tran: Transaction) => {}

  // üìí Fn[afterUpdate] (‚úÖ Inheritance): Update Transaction Ïù¥ Ïã§ÌñâÎêú ÌõÑ Ìò∏Ï∂úÎêòÎäî Function
  // afterUpdate = async(req: express.Request, result: ApiResult<any>) => {}

  //#endregion

  //#region üü† Patch Hooks

  // üìí Fn[beforePatch] (‚úÖ Inheritance): Patch Transaction Ïù¥ Ïã§ÌñâÎêòÍ∏∞ Ï†Ñ Ìò∏Ï∂úÎêòÎäî Function
  beforePatch = async(req: express.Request) => {
    // üìå ÏôÑÎ£åÎêòÏñ¥ÏûàÎäî Ïã§Ï†ÅÏù¥ ÏûàÏùÑÍ≤ΩÏö∞ Îç∞Ïù¥ÌÑ∞ ÏàòÏ†ï Î∂àÍ∞Ä
    const uuids = req.body.map((data: any) => { return data.uuid });
    const workRead = await this.repo.readRawsByUuids(uuids);
    workRead.raws.forEach((work: any) => {
      if (work.work_fg) { throw new Error(`Ïã§Ï†ÅÎ≤àÌò∏ [${work.uuid}]Í∞Ä ÏôÑÎ£åÎêòÏñ¥ Îç∞Ïù¥ÌÑ∞Î•º ÏàòÏ†ïÌï† Ïàò ÏóÜÏäµÎãàÎã§.`); }
    });
  }

  // üìí Fn[beforeTranPatch] (‚úÖ Inheritance): Patch Transaction ÎÇ¥Î∂ÄÏóêÏÑú DB Tasking Ïù¥ Ïã§ÌñâÎêòÍ∏∞ Ï†Ñ Ìò∏Ï∂úÎêòÎäî Function
  // beforeTranPatch = async(req: express.Request, tran: Transaction) => {}

  // üìí Fn[afterTranPatch] (‚úÖ Inheritance): Patch Transaction ÎÇ¥Î∂ÄÏóêÏÑú DB Tasking Ïù¥ Ïã§ÌñâÎêú ÌõÑ Ìò∏Ï∂úÎêòÎäî Function
  // afterTranPatch = async(req: express.Request, result: ApiResult<any>, tran: Transaction) => {}

  // üìí Fn[afterPatch] (‚úÖ Inheritance): Patch Transaction Ïù¥ Ïã§ÌñâÎêú ÌõÑ Ìò∏Ï∂úÎêòÎäî Function
  // afterPatch = async(req: express.Request, result: ApiResult<any>) => {}

  //#endregion

  //#region üî¥ Delete Hooks

  // üìí Fn[beforeDelete] (‚úÖ Inheritance): Delete Transaction Ïù¥ Ïã§ÌñâÎêòÍ∏∞ Ï†Ñ Ìò∏Ï∂úÎêòÎäî Function
  // beforeDelete = async(req: express.Request) => {}

  // üìí Fn[beforeTranDelete] (‚úÖ Inheritance): Delete Transaction ÎÇ¥Î∂ÄÏóêÏÑú DB Tasking Ïù¥ Ïã§ÌñâÎêòÍ∏∞ Ï†Ñ Ìò∏Ï∂úÎêòÎäî Function
  // beforeTranDelete = async(req: express.Request, tran: Transaction) => {}

  // üìí Fn[afterTranDelete] (‚úÖ Inheritance): Delete Transaction ÎÇ¥Î∂ÄÏóêÏÑú DB Tasking Ïù¥ Ïã§ÌñâÎêú ÌõÑ Ìò∏Ï∂úÎêòÎäî Function
  // afterTranDelete = async(req: express.Request, result: ApiResult<any>, tran: Transaction) => {}

  // üìí Fn[afterDelete] (‚úÖ Inheritance): Delete Transaction Ïù¥ Ïã§ÌñâÎêú ÌõÑ Ìò∏Ï∂úÎêòÎäî Function
  // afterDelete = async(req: express.Request, result: ApiResult<any>) => {}

  //#endregion

  //#endregion
}

export default PrdWorkCtl;